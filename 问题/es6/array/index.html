<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div></div>
    <div></div>
    <div></div>
</body>
<script>
    /******************************
    数组的扩展
    **************************/
    //扩展运算符...
    // console.log(...[1, 2, 3]);
    // console.log(1, ...[2, 3, 4], 5);
    // console.log([...document.querySelectorAll('div')]);
    //该运算符主要用于函数调用。
    // function push(array, ...items) {
    //     console.log("array",array);
    //     console.log("items",items);
    //     array.push(...items);
    // }

    // function add(x, y) {
    //     return x + y;
    // }

    // const numbers = [4, 38];
    // a= add(...numbers) // 42
    // push(numbers,1,2,3)
    // console.log(numbers)
    //***************************************************
    // function f(v,w, x, y,z) { 

    // }
    // const args = [0, 1];
    // f(-1, ...args, 2, ...[3]);
    //***************************************************
    // x=1
    // const arr = [
    //     ...(x > 0 ? ['a'] : []),
    //     'b',
    // ];
    // console.log(arr);
    //***************************************************
    //console.log([...[], 1]);
    //***************************************************
    // err:注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。
    //(...[1, 2])
    // console.log((...[1, 2]))
    // ok:
    // console.log(...[1, 2])
    //***************************************************
    // ES5 的写法
    // function f(x, y, z) {
    //     // ...
    //     console.log("x",x);
    //     console.log("y",y);
    //     console.log("z",z);
    // }
    // var args = [0, 1, 2];
    // f.apply(null, args);

    // ES6的写法
    // function f(x, y, z) {
    //     // ...
    //     console.log("x",x);
    //     console.log("y",y);
    //     console.log("z",z);
    // }
    // let args = [0, 1, 2];
    // f(...args);
    //***************************************************
    // ES5 的写法
    // console.log(Math.max.apply(null, [14, 3, 77]));
    // // ES6 的写法
    // console.log(Math.max(...[14, 3, 77]));
    // // 等同于
    // console.log(Math.max(14, 3, 77));
    //***************************************************
    // ES5的 写法
    // var arr1 = [0, 1, 2];
    // var arr2 = [3, 4, 5];
    // Array.prototype.push.apply(arr1, arr2);
    // console.log(arr1);
    // console.log(arr2);
    // ES6 的写法
    // let arr1 = [0, 1, 2];
    // let arr2 = [3, 4, 5];
    // arr1.push(...arr2);
    // console.log(arr1);
    // console.log(arr2);
    //***************************************************
//    console.log(new (Date.bind.apply(Date, [null, 2015, 1, 1])));
//    console.log(new Date(...[2015, 1, 1]));
    //***************************************************
    //#######扩展运算符的应用########
    //1.复制数组
    // const a1 = [1, 2];
    // const a2 = a1;

    // a2[0] = 2;
    // console.log(a1);
    // console.log(a2);
    // a1 // [2, 2]
    // 上面代码中，`a2`并不是`a1`的克隆，而是指向同一份数据的另一个指针。
    //修改`a2`，会直接导致`a1`的变化。
    // ES5 只能用变通方法来复制数组。
    // const a1 = [1, 2];
    // const a2 = a1.concat();

    // a2[0] = 2;
    // console.log(a1);
    // console.log(a2);
   // a1 // [1, 2]
  // 上面代码中，`a1`会返回原数组的克隆，再修改`a2`就不会对`a1`产生影响。
   // 扩展运算符提供了复制数组的简便写法。

    //javascript
    //const a1 = [1, 2];

    // 写法一
    // const a2 = [...a1];
    // a2[0] = 2;
    // console.log(a1);
    // console.log(a2);
     // 写法二
    // const [...a2] = a1;
    // a2[0] = 2;
    // console.log(a1);
    // console.log(a2);

    //上面的两种写法，`a2`都是`a1`的克隆。
    //***************************************************
    //#########2.合并数组#################
    // const arr1 = ['a', 'b'];
    // const arr2 = ['c'];
    // const arr3 = ['d', 'e'];
    // // ES5 的合并数组
    // console.log(arr1.concat(arr2, arr3));
    // // ES6 的合并数组
    // console.log([...arr1, ...arr2, ...arr3]);
    //不过，这两种方法都是浅拷贝，使用的时候需要注意。
    // const a1 = [{ foo: 1 }];
    // const a2 = [{ bar: 2 }];

    // const a3 = a1.concat(a2);
    // const a4 = [...a1, ...a2];

    
    // console.log(a3[0] === a1[0]);// true
    // console.log(a4[0] === a1[0]);// true
    
    //上面代码中，`a3`和`a4`是用两种不同方法合并而成的新数组，
    //但是它们的成员都是对原数组成员的引用，这就是浅拷贝。
    //如果修改了引用指向的值，会同步反映到新数组。
    //***************************************************
    //#########3.与解构赋值结合#################
    // ES5
    // a = list[0], 
    // rest = list.slice(1)
    // // ES6
    // [a, ...rest] = list
    // const [first, ...rest] = [1, 2, 3, 4, 5];
    // console.log(first);
    // console.log(rest);
    // first // 1
    // rest  // [2, 3, 4, 5]

    // const [first, ...rest] = [];
    // console.log(first);
    // console.log(rest);
    // first // undefined
    // rest  // []

    // const [first, ...rest] = ["foo"];
    // console.log(first);
    // console.log(rest);
    // first  // "foo"
    // rest   // []

    //如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

    // javascript
    // const [...butLast, last] = [1, 2, 3, 4, 5];
    // // 报错

    // const [first, ...middle, last] = [1, 2, 3, 4, 5];
    // // 报错
    
    // //***************************************************
    //############4.字符串####################

    //***************************************************
    //***************************************************
    //***************************************************
    //***************************************************
    //***************************************************
    //***************************************************
</script>

</html>